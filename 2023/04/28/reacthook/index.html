<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="一个刘庆伟用来写博客的地方"><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>React Hooks 全方位解析</title><link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.2"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.png"></div><div class="author"><div class="author-name"><a href="/">刘庆伟的日志中心</a></div><div class="about-me">一个渣渣前端切图仔用来写日志的地方</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.png"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/qwei79"></span><a href="https://github.com/qwei79" target="_blank" title="https://github.com/qwei79">https://github.com/qwei79</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="qwei@msn.com"></span><span>qwei@msn.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="liuqw579"></span><span>liuqw579</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">React Hooks 全方位解析</div><div class="date">写于2023年04月28日</div><div class="content"><p>React 是一种非常流行的 JavaScript 库，而 React 中的 Hooks 则是 React 16.8 版本中的新特性，它使 React 组件的状态管理和逻辑重构变得更加简单和优雅。那么今天就来给大家聊聊 React 中的 Hooks，包括 useState、useEffect、useContext、useReducer、useCallback、useMemo、useRef 和 useImperativeHandle。</p>
<h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState"></a>1. useState</h3><p>useState 是 React 可以让函数式组件也可以拥有状态。useState 接收一个初始状态值，并返回一个包含初始状态值和更新状态值的数组。通过 useState，我们可以在函数式组件中定义和使用状态，并根据用户交互或其他事件来修改状态。来，让我们看一段示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们定义了一个名为 count 的状态变量，并通过调用 useState 来初始化为 0。我们还定义了一个名为 setCount 的函数，用于更新 count 状态变量。在组件的渲染过程中，使用 count 变量展示页面上按钮被点击的次数，并通过调用 setCount 来更新 count 状态变量。 </p>
<h3 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. useEffect</h3><p>useEffect 让函数式组件也可以处理类似于生命周期事件的副作用，例如获取数据、订阅事件、操作 DOM 等。我们可以使用 useEffect 实现组件的挂载、更新和卸载等生命周期的相关操作，也可以在 useEffect 中处理一些需要解绑的事件、网络请求等副作用。<br>useEffect 接收两个参数，第一个参数是需要执行的函数，第二个参数是一个数组，用于指定 useEffect 需要监听的状态变量数组。函数将在组件渲染后执行，并在组件被卸载时进行清理。依赖项数组用于告诉React什么时候应该重新运行副作用。<br>例如，我们可以通过以下方式在函数式组件中使用 useEffect：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们定义了一个名为 count 的状态变量，并通过调用 useState 来初始化为 0。我们使用 useEffect 来监听 count 的变化，当 count 发生变化时，我们通过设置 document.title 实现动态的页面标题。在组件的渲染过程中，使用 count 变量展示页面上按钮被点击的次数，并通过调用 setCount 来更新 count 状态变量。</p>
<h3 id="3-useContext"><a href="#3-useContext" class="headerlink" title="3. useContext"></a>3. useContext</h3><p>useContext 提供了一个让组件之间共享数据的方式，避免了层层传递 props 的麻烦。它允许我们在函数组件中轻松地访问 React Context 的值。它接收一个 Context 对象并返回当前 Context 值。就像在类组件中使用 this.context 一样，使用 useContext 可以访问在 Context.Provider 中定义的任何值。我们只需要在父组件中使用 createContext 创建一个上下文，然后通过 useContext 来在子组件中消费上下文中的数据即可。来看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;World&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了一个名为 MyContext 的上下文对象，并通过 createContext 函数创建了一个默认值为 “Hello” 的上下文。 在子组件 Child 中使用 useContext(MyContext) 来获取 MyContext 上下文中的数据，并在渲染过程中将其展示在页面上。 在父组件 Parent 中通过在 MyContext.Provider 组件中使用 value 来设置 MyContext 上下文的值为 “World” 。</p>
<h3 id="4-useReducer"><a href="#4-useReducer" class="headerlink" title="4. useReducer"></a>4. useReducer</h3><p>useReducer 可以用于处理具有复杂状态逻辑的组件。它的作用类似于 Redux 中的 reducer，但是它可以更轻量级地管理组件的局部状态。它接收一个 reducer 函数和一个初始状态，并返回一个包含状态和 dispatch 函数的元组。用于派发更新操作。使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;state.count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，我们定义了一个 initialState 作为初始状态值，以及一个 reducer 函数来处理状态的变化。 接着，在 Counter 组件中使用 useReducer 将 initialState 和 reducer 函数传递给 useReducer，并返回了一个包含了状态值和 dispatch 函数的数组。 这个状态值可以在组件中直接使用，而 dispatch 函数可以接收一个 action 对象，用来触发 reducer 函数的执行以更新状态。</p>
<h3 id="5-useCallback"><a href="#5-useCallback" class="headerlink" title="5. useCallback"></a>5. useCallback</h3><p>useCallback 用于返回一个 memoized（记忆化）的回调函数，以避免在每次重新渲染组件时都创建新的函数。使用 useCallback 可以有效地优化 React 应用程序的性能。<br>useCallback 接收两个参数：回调函数和一个依赖项数组（可选）。只有当依赖项数组中的某个值发生变化时，useCallback 才会返回一个新的回调函数；否则，它将返回先前缓存的回调函数。咱来看一段示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">&#123; onButtonClick &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onButtonClick</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  &#125;, [onButtonClick]);</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们将 handleClick 函数传递给了按钮的 onClick 属性。由于我们希望每次重新渲染组件时都不会创建新的函数，因此我们使用 useCallback 缓存了 handleClick 函数并将 onButtonClick 作为依赖项传递给 useCallback。这意味着只有当 onButtonClick 改变时，useCallback 才会返回一个新的函数。</p>
<h3 id="6-useMemo"><a href="#6-useMemo" class="headerlink" title="6. useMemo"></a>6. useMemo</h3><p>useMemo 用于返回一个 memoized（记忆化）值。与 useCallback 类似，使用 useMemo 可以避免在每次重新渲染组件时都重新计算值，从而有效地优化 React 应用程序的性能。一般来说，当计算一个值比较耗时时，可以使用 useMemo 来避免不必要的重复计算。<br>useMemo 接收两个参数：计算值的函数和一个依赖项数组（可选）。只有当依赖项数组中的某个值发生变化时，useMemo 才会重新计算并返回一个新的值；否则，它将返回先前缓存的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">&#123; itemCount &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> message = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;itemCount&#125;</span> items`</span>;</span><br><span class="line">  &#125;, [itemCount]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用 useMemo 缓存消息字符串的计算结果并将 itemCount 作为依赖项传递给 useMemo。这意味着只有当 itemCount 改变时，useMemo 才会重新计算并返回一个新的消息字符串。</p>
<h3 id="7-useRef"><a href="#7-useRef" class="headerlink" title="7. useRef"></a>7. useRef</h3><p>useRef 用于在函数式组件中保存和更新可变值。相对于 useState，useRef 保存的值可以在组件重新渲染时保持不变，并且更新这些值不会触发组件的重新渲染。<br>useRef 返回一个可变的 ref 对象，该对象具有一个 current 属性，该属性被初始化为传递给 useRef 的参数。ref 对象可以在组件的整个生命周期中使用，而无需重新声明或重新初始化变量。ref 对象的 current 属性可以被读取和更新，而不会触发组件的重新渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Focus Input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用 useRef 来创建一个 inputRef 对象，并将其分配给 input 元素的 ref 属性。然后，我们可以在 handleClick 函数内部使用 inputRef.current.focus() 来将焦点设置在输入框中。<br>除了保存和更新 DOM 元素的引用，useRef 还可以用于保存和更新任何可变值，例如计时器 ID、WebSocket 连接、或者其他需要在组件渲染周期内保持不变的值。</p>
<h3 id="8-useImperativeHandle"><a href="#8-useImperativeHandle" class="headerlink" title="8. useImperativeHandle"></a>8. useImperativeHandle</h3><p>useImperativeHandle 允许我们将特定方法向下传递到子组件以便在需要时调用它。也就是说可以让我们在函数式组件中控制父组件直接调用子组件中暴露出来的方法或属性。useImperativeHandle 需要与 forwardRef 一起使用，forwardRef 可以将父组件传递给子组件。具体来讲，useImperativeHandle 接受两个参数，一个 ref 和一个提供给该 ref 的回调函数，在回调函数中定义子组件向父组件暴露出的方法或属性，并返回一个值或函数，该值或函数可以从 ref 中访问。说起来挺绕口的，我们还是看代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; forwardRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> childRef = <span class="title function_">useRef</span>();</span><br><span class="line">  <span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">focusChild</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      childRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">someValue</span>: <span class="string">&#x27;我是子组件暴露出来的属性&#x27;</span>,</span><br><span class="line">  &#125;));</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;childRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> childRef = <span class="title function_">useRef</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    childRef.<span class="property">current</span>.<span class="property">focusChild</span> &amp;&amp; childRef.<span class="property">current</span>.<span class="title function_">focusChild</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;childRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Focus Input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Parent</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了一个 Child 组件，用 useRef 来创建一个 childRef 对象，以便可以在回调函数中使用。在 useImperativeHandle 中，我们定义了 focusChild 方法和 someValue 属性，并将其返回给父组件。回调函数返回的对象将被与传递给 forwardRef 的 ref 对象合并。在 Parent 组件中，我们通过点击按钮的方式来调用子组件的 focusChild 方法，使输入框获得焦点。</p>
<p>React 中的主要 Hooks 就这几个，使用它们可以让代码更简洁、优雅和易于维护。当然，这些 Hooks 的应用场景远不止这些，大家可以在实际使用中不断探索它们的真正潜力。</p>
</div><div class="tags"></div></section></div><div class="container"><ul class="nav"><li>下一篇：<a href="/2023/04/27/promise/">promise</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" target="_blank">Bear</a><span>.</span></div></footer>
<script src="/script/jquery.min.js"></script>

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/script/index.js"></script>

<script src="/script/post.js"></script>
</body></html>