<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="一个刘庆伟用来写博客的地方"><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>promise</title><link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.2"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.png"></div><div class="author"><div class="author-name"><a href="/">刘庆伟的日志中心</a></div><div class="about-me">一个渣渣前端切图仔用来写日志的地方</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.png"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/qwei79"></span><a href="https://github.com/qwei79" target="_blank" title="https://github.com/qwei79">https://github.com/qwei79</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="qwei@msn.com"></span><span>qwei@msn.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="liuqw579"></span><span>liuqw579</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">promise</div><div class="date">写于2023年04月27日</div><div class="content"><p>作为前端开发者，promise是非常重要的一个概念。在开发现代Web应用程序时，处理异步操作是非常重要的一部分。如果不使用promise，代码将变得难以维护和理解。在日常开发中，我们经常需要处理异步操作，如从服务器请求数据或在浏览器中执行用户交互操作等。在 JavaScript 中，Promise 是一种强大的工具，它可以帮助我们更轻松地处理异步操作。</p>
<h3 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h3><p>首先，让我们了解一下什么是promise。Promise 是一种 JavaScript 对象，用于表示一个异步操作的最终结果，它代表一个异步操作的最终完成或者失败。Promise 对象可以有三种状态：pending（等待中）、fulfilled（已完成）和 rejected（已拒绝）。当我们发起一个异步操作时，Promise 对象最初处于等待状态，此时它不知道操作的结果。一旦操作完成，Promise 对象将进入已完成或已拒绝状态。在已完成状态下，我们可以通过 .then() 方法获取操作的结果，而在已拒绝状态下，可以通过 .catch() 方法获取操作失败的原因。使用promise，我们可以处理异步操作的结果，而不必等待它完成。与传统的回调方式相比，promise的使用更加清晰明了，更容易处理错误和异常情况。 </p>
<h3 id="Promise-的语法"><a href="#Promise-的语法" class="headerlink" title="Promise 的语法"></a>Promise 的语法</h3><p>Promise 使用起来非常简单，其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作代码</span></span><br><span class="line">  <span class="keyword">if</span> (操作成功) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(result);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> promise.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 操作成功后的处理代码</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 操作失败后的处理代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先创建了一个 Promise 对象，并传入一个函数作为参数，该函数包含异步操作的代码。如果异步操作成功，我们调用 resolve() 方法来设置 Promise 对象的状态为已完成，并提供操作结果作为参数。如果异步操作失败，我们调用 reject() 方法来设置 Promise 对象的状态为已拒绝，并提供操作失败的原因作为参数。最后，我们使用 .then() 和 .catch() 方法来处理操作的结果或失败原因。</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在实际开发中，我们经常需要使用promise来处理异步操作。在下面的代码片段中，我们可以看到如何使用promise来加载图片，并在加载完成后执行回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImage</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(image);</span><br><span class="line">    &#125;;</span><br><span class="line">    image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line">    image.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">loadImage</span>(<span class="string">&#x27;https://example.com/image.png&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">image</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Image loaded: &#x27;</span>, image);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用了Promise构造函数创建了一个promise对象。在这个promise对象中，我们会去加载指定url的图片，并在图片加载完成后执行resolve回调函数。如果图片加载失败，则执行reject回调函数。通过这种方式，我们可以更加方便地处理异步操作的结果。</p>
<p>另一个重要的方面是使用promise进行异步操作的链式调用。在下面的代码片段中，我们可以看到如何使用promise链式调用，来处理多个异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncOperation1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;Operation 1 complete&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncOperation2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;Operation 2 complete&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncOperation3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;Operation 3 complete&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncOperation1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">asyncOperation2</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">asyncOperation3</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用了Promise的then方法来链式调用多个异步操作。每个then方法都返回一个新的promise对象，使得我们可以在每次异步操作结束后，继续执行下一个异步操作。这种方式非常方便，可以让我们更好地组织和管理异步操作。 </p>
<h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>总结起来，promise是处理异步操作的一种非常方便和强大的工具。它可以让我们更好地处理异步操作的结果，而不必等待它们的完成。同时，通过链式调用多个promise，我们可以更好地组织和管理异步操作。<br>在本文中，我们深入了解了 Promise 的用法，并探讨了如何使用它来处理异步操作。Promise 是一个非常有用的工具，它可以帮助我们更轻松地处理异步代码，并提高代码的可读性和可维护性。</p>
</div><div class="tags"></div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2023/04/28/reacthook/">React Hooks 全方位解析</a></li><li>下一篇：<a href="/2023/04/26/deepclone/">深拷贝咋就这么难呢？</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" target="_blank">Bear</a><span>.</span></div></footer>
<script src="/script/jquery.min.js"></script>

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/script/index.js"></script>

<script src="/script/post.js"></script>
</body></html>