<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="一个刘庆伟用来写博客的地方"><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>深拷贝咋就这么难呢？</title><link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.2"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.png"></div><div class="author"><div class="author-name"><a href="/">刘庆伟的日志中心</a></div><div class="about-me">一个渣渣前端切图仔用来写日志的地方</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.png"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/qwei79"></span><a href="https://github.com/qwei79" target="_blank" title="https://github.com/qwei79">https://github.com/qwei79</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="qwei@msn.com"></span><span>qwei@msn.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="liuqw579"></span><span>liuqw579</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">深拷贝咋就这么难呢？</div><div class="date">写于2023年04月26日</div><div class="content"><p>当我们写前端代码的时候，有时候需要把一个对象赋值给另一个对象，但是又不能直接赋值，要进行深拷贝，以便随时可以修改和保存对象的数据状态。但是，在深拷贝过程中，有一个特别烦人的问题，就是循环引用。如果出现循环引用的情况，就会导致程序陷入死循环或抛出异常。那该怎么办呢？</p>
<h3 id="有几个好用的方法可以解决这个问题"><a href="#有几个好用的方法可以解决这个问题" class="headerlink" title="有几个好用的方法可以解决这个问题"></a>有几个好用的方法可以解决这个问题</h3><hr>
<h4 id="1-我们可以使用第三方库。"><a href="#1-我们可以使用第三方库。" class="headerlink" title="1. 我们可以使用第三方库。"></a>1. 我们可以使用第三方库。</h4><p>前端开发中有很多第三方库可以用来完成深拷贝操作。比如，Lodash 中有一个  <code>cloneDeep</code>  方法，可以完成深度拷贝，并且内置了循环引用的处理逻辑，当遇到循环引用时，会直接返回已经访问过的对象。同样的，jQuery 中也有一个  <code>$.extend(true, &#123;&#125;, obj)</code>  方法，可以完成深度拷贝，并且也内置了循环引用的处理逻辑。如果你的项目中已经引入了这些库，那么完成深拷贝就变得非常容易了。</p>
<hr>
<h4 id="2-我们也可以自己实现深拷贝方法。"><a href="#2-我们也可以自己实现深拷贝方法。" class="headerlink" title="2. 我们也可以自己实现深拷贝方法。"></a>2. 我们也可以自己实现深拷贝方法。</h4><p>我们可以自己实现深拷贝方法，并且要能够处理循环引用问题，这时候，要用到一个神奇的工具—— <code>WeakMap</code> ，可以记录已经拷贝过的对象，在遇到循环引用时，直接返回记录的对象。下面是一个简单的实现示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>(obj) !== obj) <span class="keyword">return</span> obj; <span class="comment">// 基本数据类型直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj); <span class="comment">// 已经访问过，直接返回</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  hash.<span class="title function_">set</span>(obj, result); <span class="comment">// 记录已访问过的对象</span></span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>(obj[key]) === obj[key]) &#123;</span><br><span class="line">      result[key] = <span class="title function_">deepClone</span>(obj[key], hash);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们使用了一个  <code>WeakMap</code>  对象来记录已经访问过的对象。如果这个对象已经访问过了，就直接返回记录的对象；否则，就递归拷贝这个对象，并将拷贝后的新对象记录在  <code>WeakMap</code>  中。</p>
<hr>
<h4 id="3-使用-ES6-的-Map-对象"><a href="#3-使用-ES6-的-Map-对象" class="headerlink" title="3. 使用 ES6 的 Map 对象"></a>3. 使用 ES6 的 <code>Map</code> 对象</h4><p>ES6 中引入了 <code>Map</code> 对象，可以用来存储键值对。我们可以使用 Map 对象来记录已经拷贝过的对象，避免处理循环引用问题。下面是一个简单的实现示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>(obj) !== obj) <span class="keyword">return</span> obj; <span class="comment">// 基本数据类型直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> map.<span class="title function_">get</span>(obj); <span class="comment">// 已经访问过，直接返回</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  map.<span class="title function_">set</span>(obj, result); <span class="comment">// 记录已访问过的对象</span></span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>(obj[key]) === obj[key]) &#123;</span><br><span class="line">      result[key] = <span class="title function_">deepClone</span>(obj[key], map);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们使用了一个 <code>Map</code> 对象来记录已经访问过的对象。如果对象已经访问过了，就直接返回记录的对象；否则，就递归拷贝这个对象，并将拷贝后的新对象记录在 <code>Map</code> 中。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>循环引用是深拷贝中一个常见的问题，但是我们可以使用第三方库、自己实现深拷贝方法并记录已经访问过的对象、或者使用 ES6 的 <code>Map</code> 对象来避免这个问题。在编写深拷贝代码时，我们应该优先考虑使用已经成熟的第三方库，因为这些库已经经过充分的实践和测试，可以提供更好的性能和稳定性。总之，解决循环引用问题不是一件简单的事情，但是，在不断地实践中，我们就可以掌握更多的技能，写出更好的代码，成为更加优秀的前端工程师。</p>
</div><div class="tags"></div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2023/04/27/promise/">promise</a></li><li>下一篇：<a href="/2023/04/25/base64%E6%98%AF%E5%8A%A0%E5%AF%86%E8%BF%98%E6%98%AF%E7%BC%96%E7%A0%81%EF%BC%9F%E6%88%91%E7%94%A8JS%E6%9D%A5%E8%AE%B2%E7%BB%99%E4%BD%A0%E5%90%AC%E3%80%82/">base64是加密还是编码？我用JS来讲给你听。</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" target="_blank">Bear</a><span>.</span></div></footer>
<script src="/script/jquery.min.js"></script>

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/script/index.js"></script>

<script src="/script/post.js"></script>
</body></html>